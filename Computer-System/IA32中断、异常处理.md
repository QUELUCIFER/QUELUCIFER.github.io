1单选(1.25分)
以下关于IA-32/Linux异常/中断处理的叙述中，错误的是（   ）。

得分/总分

A.
Linux完全按照IA-32的门描述符类型构造了三种门描述符

1.25/1.25

B.
IA-32硬件负责对异常事件和中断请求进行检测和响应


C.
中断服务程序和异常处理程序属于Linux内核部分


D.
在系统启动过程中由Linux负责对IDT的初始化

正确答案：A你选对了
解析：  A、IA-32规定IDT的每个表项可以是三种门描述符中的一种：中断门（TYPE=1110B）、陷阱门（TYPE=1111B）和任务门（TYPE=0101B）。
而Linux通过对TYPE和DPL的组合构造了5种门描述符：中断门、系统门、系统中断门、陷阱门和任务门。

2单选(1.25分)
根据Linux对IDT中每种门描述符的初始化构建，以下指令中，不能在用户态执行的是（   ）。

得分/总分

A.
int 3


B.
into


C.
int 20

1.25/1.25

D.
int $0x80

正确答案：C你选对了
解析：  C、Linux通过对TYPE和DPL的组合构造了5种门描述符：中断门、系统门（DPL=3，TYPE=1111B）、系统中断门（DPL=3，TYPE=1110B）、陷阱门（DPL=0，TYPE=1111B）和任务门。
类型4（into）和128（int $0x80）初始化为系统门，类型3（int 3）初始化为系统中断门，这两种门描述符的DPL都为3。所有未定义的类型（如20~31）都属于陷阱门，即DPL为0。
在异常/中断响应过程中，对于编程异常（由INT n等陷阱指令引起的异常），若IDT中的DPL<CPL，则产生13号异常。into、int $0x80和int 3三条指令执行时，DPL=CPL=3，
故可在用户态执行；若在用户态执行INT n （n=20~31）指令，则DPL<CPL，产生13号异常，因此不能在用户态执行。

3单选(1.25分)
以下关于IA-32/Linux异常/中断处理的叙述中，错误的是（   ）。

得分/总分

A.
Linux对大多数异常的处理方式是发送相应信号给用户进程以尽快结束异常处理过程


B.Linux中异常处理的C函数名由do_前缀和处理程序名组成，与相应信号处理程序名相同1.25/1.25

C.
Linux中对中断的处理不采用发送信号给用户进程的方式，而是对相应中断进行具体处理


D.
 Linux需要针对IA-32的256个中断设置IDT对应表项的内容，即进行IDT的初始化

正确答案：B你选对了
解析：  B、在Linux系统中，信号处理程序名和异常处理程序名不相同，例如，对于0号“除法错”异常和16号“浮点错误”异常，它们的信号名都为SIGFPE，因而相应的信号处理程序名相同，
但是，它们默认的异常处理程序名各为divide_error()和coprocessor_error()。

4单选(1.25分)
以下关于IA-32/Linux对14号页故障（page fault）处理的叙述中，错误的是（   ）。若发生访问越级（用户进程访问了内核空间），则发送SIGSEGV信号

得分/总分

A.
若发生访问越界（例如访问无信息的空洞页面），则发送SIGSEGV信号


B.
若发生访问越级（用户进程访问了内核空间），则发送SIGSEGV信号


C.
若发生访问越权（例如对只读代码区进行写），则发送SIGSEGV信号


D.
若发生所需页面不在主存（页表中存在位为0），则发送SIGSEGV信号

1.25/1.25
正确答案：D你选对了
解析：  D、若异常不能修复，则发送相应信号给发生异常的进程；若异常可以修复，则进行故障修复后回到发生异常的指令继续执行。显然，所需页面不在主存的情况是可以修复的，
因而不会发送SIGSEGV信号。

5单选(1.25分)
以下关于IA-32/Linux异常处理程序的叙述中，错误的是（   ）。

得分/总分

A.
最后一条指令为iret，用于完成异常处理的返回工作


B.
准备阶段会在内核栈中保存EFLAGS的内容

1.25/1.25

C.
处理阶段执行的C函数名的形式为“do_处理程序名”


D.
准备阶段会在内核栈中保存通用寄存器的内容

正确答案：B你选对了
解析：  B、EFLAGS寄存器是在异常/中断响应过程中保存在内核栈的，而不是在异常处理程序中被保存。

6单选(1.25分)
IA-32/Linux系统中一次中断过程为（   ）。

得分/总分

A.
中断源向PIC请求（IRQi）→ PIC中断查询 → CPU读取中断类型号并访问IDT获得中断服务程序入口地址 → PIC向CPU请求（INTR）→ CPU中断回答（INTA）→ Linux内核进行中断处理

0.00/1.25

B.
中断源向PIC请求（IRQi）→ PIC向CPU请求（INTR）→ PIC中断查询 → CPU中断回答（INTA）→ CPU读取中断类型号并访问IDT获得中断服务程序入口地址 → Linux内核进行中断处理


C.
### 中断源向PIC请求（IRQi）→ PIC向CPU请求（INTR）→ CPU中断回答（INTA）→ PIC中断查询 →CPU读取中断类型号并访问IDT获得中断服务程序入口地址 → Linux内核进行中断处理


D.
中断源向PIC请求（IRQi）→ PIC中断查询 → PIC向CPU请求（INTR）→ CPU中断回答（INTA）→ CPU读取中断类型号并访问IDT获得中断服务程序入口地址 → Linux内核进行中断处理

正确答案：C你错选为A

7单选(1.25分)
以下关于IA-32/Linux系统调用的叙述中，错误的是（  ）。

得分/总分

A.
所有系统调用有统一的入口，即系统调用处理程序system_call第一条指令地址


B.
执行陷阱指令过程中所完成的操作类似于异常/中断响应过程中完成的任务

C.系统调用是一种特殊的异常类型，IA-32中把它的中断类型号设定为1281.25/1.25

D.
系统调用使用陷阱指令实现，Linux系统中可执行int $0x80指令进行系统调用

正确答案：C你选对了
解析：  C、系统调用使用陷阱指令实现，因而是一种特殊的异常类型。Linux系统中可执行int $0x80指令进行系统调用，因此，系统调用对应的中断类型号为0x80=128，
不过，这是Linux操作系统设定的，而不是由IA-32设定的。例如，Windows操作系统中通过执行int $0x2e指令发出系统调用，因此对应的中断类型号为0x2e=46。

8单选(1.25分)
以下是关于IA-32/Linux中call指令和int $0x80指令比较的叙述，其中错误的是（  ）。

得分/总分

A.
call指令为同一特权级过程调用，而int $0x80指令实现对内核服务例程的调用


B.
call指令和int $0x80指令执行过程中，都会将下一条指令的地址保存在栈中


C.
call指令和int $0x80指令都有对应返回指令，前者是ret指令，后者是iret指令


D.
call指令和int $0x80指令执行前，都会由mov指令将参数值传送到栈中保存

1.25/1.25
正确答案：D你选对了
解析：  D、int $0x80指令执行前，参数由mov指令送到对应的寄存器中，例如，调用号送到EAX，其他参数从左到右依次在EBX、ECX、EDX、ESI、EDI和EBP中，而call指令前传递的参数是送到栈中保存的。
