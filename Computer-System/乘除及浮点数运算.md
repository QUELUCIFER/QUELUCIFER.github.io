### 对于C语言程序中的表达式z=x*y，其中x,y和z都是32位的int型整数，z的取值为x*y的64位乘积中的低32位。

### 在计算机内部，一个整数x的平方可能是负数，这是因为在计算机中其结果取的是x*x的低n位乘积而高n位中的有效数位被丢弃而造成的。 

### 以下是关于整数乘运算（z=x*y）结果溢出判断规则的描述，其中错误的是（    ）。


A.
如果是C语言程序员，可以采用"若(y!=0 || x==z/y)，则结果z不溢出"的规则。


B.
若x,y,z为无符号整数，则编译器可以采用"若z的高n为全0，则不溢出，否则溢出"的规则。


C.
若x,y,z为带符号整数，则编译器可以采用"若z的高n+1位为全0或全1，则不溢出，否则溢出"的规则。


D.
高级语言程序员使用高级语言语句实现溢出判断，而编译器使用若干条指令进行溢出判断。

正确答案：A你选对了

![浮点数](https://upload-images.jianshu.io/upload_images/9379599-8dd5485ed36ba870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp)

第1位表示正负，中间8位表示指数，后23位储存有效数位（有效数位是24位）。

第一位的正负号0代表正，1代表负。

中间八位共可表示28=256个数，指数可以是二补码；或0到255，0到126代表-127到-1，127代表零，128-255代表1-128。

有效数位最左手边的1并不会储存，因为它一定存在（二进制的第一个有效数字必定是1）。换言之，有效数位是24位，实际储存23位。

![simplex-precision-float](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Float_example.svg/590px-Float_example.svg.png)

{\displaystyle {\text{sign}}=+1} {\displaystyle {\text{sign}}=+1}
{\displaystyle {\text{exponent}}=(-127)+124=-3} {\displaystyle {\text{exponent}}=(-127)+124=-3}
{\displaystyle {\text{fraction}}=1+2^{-2}=1.25} {\text{fraction}}=1+2^{{-2}}=1.25
{\displaystyle {\text{value}}=(+1)\times 1.25\times 2^{-3}=+0.15625} {\displaystyle {\text{value}}=(+1)\times 1.25\times 2^{-3}=+0.15625}

### 1单选 (0.5分)
若在一个8 位计算机中完成x+2y 的运算，假定变量x 和y 的机器数用补码表示为[x] 补=44H ，[y] 补= DCH ，则x+2y 的机器数及相应的溢出标志OF 分别是（）。    

得分/总分

A.
32H 、0


B.
FCH 、0

0.50/0.50

C.
FCH 、1


D.
 32H 、1

正确答案：B 你选对了
解析：   B、x和y的机器数是用补码表示的，分别是0100 0100、1101 1100，因为是做x+2y，所以，先对y算术左移一位，然后和x相加，此时sub=0，即0100 0100 + 1011 1000+0 = 1111 1100（FCH），因为两个加数符号相异，所以不会发生溢出，即OF=0。
2单选 (0.5分)
若在一个8 位计算机中完成x–2y ，假定变量x 和y 的机器数用补码表示为[x] 补=44H ，[y] 补= DCH ，则x–2y 的机器数及相应的溢出标志OF 分别是（    ）。

得分/总分

A.
68H 、1


B.
68H 、0


C.
8CH 、0


D.
8CH 、1

0.50/0.50
正确答案：D 你选对了
解析：   D、x和y的机器数是用补码表示的，分别是0100 0100、1101 1100，因为是做x–2y，所以，先对y算术左移一位，得1011 1000，然后各位取反，再和x相加，此时sub=1，即0100 0100 + 0100 0111+1 = 1000 1100（8CH），因为两个加数符号都为0，而结果符号为1，所以发生了溢出，即OF=1。
3单选 (0.5分)
若在一个8 位计算机中完成x/2+2y ，假定变量x 和y 的机器数用补码表示为[x] 补=44H ，[y] 补= DCH ，则x/2+2y 的机器数及相应的溢出标志OF 分别是（）。   

得分/总分

A.
CAH 、1


B.
 DAH 、0

0.50/0.50

C.
DAH 、1


D.
CAH 、0

正确答案：B 你选对了
解析：   B、x和y的机器数是用补码表示的，分别是0100 0100、1101 1100，因为是做x/2+2y，所以，先对x算术右移一位，得0010 0010；再对y算术左移一位，得1011 1000，两者相加，此时sub=0，即0010 0010 + 1011 1000+0 = 1101 1010（DAH），因为两个加数符号相异，所以不会发生溢出，即OF=0。
4单选 (0.5分)
假定变量r1 和r2 的机器数用8 位补码表示为[r1] 补=F5H ，[r2] 补=EEH 。若将运算结果存放在一个8 位寄存器中，则下列运算中会发生溢出的是（）。    

得分/总分

A.
r1+ r2


B.
r1/r2


C.
r1– r2


D.
r1× r2

0.50/0.50
正确答案：D 你选对了
5单选 (0.5分)
假定整数加法指令、整数减法指令和移位指令所需时钟周期（CPI ）都为1 ，整数乘法指令所需时钟周期为10 。若x 为整型变量，为了使计算64*x 所用时钟周期数最少，编译器应选用的最佳指令序列为（）。   

得分/总分

A.
1 条乘法指令


B.
两条左移指令和两条加法指令


C.
1 条左移指令

0.50/0.50

D.
1 条左移指令和1 条加法指令

正确答案：C 你选对了
解析：   C、因为64*x可以用x左移6位来实现，左移指令比乘法指令快10倍，因此最佳指令序列为1条左移指令，只要一个时钟周期。
6单选 (0.5分)
假定整数加法指令、整数减法指令和移位指令所需时钟周期（CPI ）都为1 ，整数乘法指令所需时钟周期为10 。若x 为整型变量，为了使计算54*x 所用时钟周期数最少，编译器应选用的最佳指令序列为（）。   

得分/总分

A.
3 条左移指令和两条减法指令

0.50/0.50

B.
4 条左移指令和3 条加法指令


C.
1 条乘法指令


D.
两条左移指令和两条减法指令

正确答案：A 你选对了
解析：   A、54*x=(64-8-2) *x=64*x -8*x -2*x，可用3条左移指令和两条减法指令来实现，共需5个时钟周期。C、一条整数乘法指令需要10个时钟周期。D、给出的指令序列肯定不能实现54*x。
7单选 (0.5分)
假定整数加法指令、逻辑运算指令和移位指令所需时钟周期（CPI ）都为1 ，整数除法指令所需时钟周期为32 。若x 为整型变量，为了使计算x/64 所用时钟周期数最少，编译器应选用的最佳指令序列为（）。   

得分/总分

A.
1 条加法指令、1 条右移指令


B.
1 条右移指令


C.
1 条除法指令


D.
两条右移指令、1 条与操作指令、1 条加法指令

0.50/0.50
正确答案：D 你选对了
解析：   A、若x为负数，则x/64=(x+63)>>6，但该公式不适合正数x，因此无法用一条加和一条右移指令实现。B、若x为负数且不能被64整除，则x右移6位和x/64的结果不相等。C、一条整数乘法指令需要32个时钟周期。D、x/64 = ( x>=0 ? x : (x+63) ) >> 6，因此关键是计算偏移量b，这里，x为正时b=0，x为负时b=63 。可从x的符号得到b，x>>31得到32位符号，正数为32位0，负数为32位1，然后通过“与”操作提取低6位，这就是偏移量b。也即：x/64 = ( x+ ( x>>31)&0x3F ) ) >> 6，用2条右移、1条加和1条与指令即可实现，只要4个时钟周期。
8单选 (0.5分)
已知float 型变量用IEEE 754 单精度浮点格式表示，float型变量x 和y 的机器数分别表示为x=40E8 0000H ，y=C204 0000H ，则在计算x+y 时，第一步对阶操作的结果[Ex - Ey] 补为（）。   

得分/总分

A.
1111 1011


B.
0000 0011


C.
0000 0111


D.
1111 1101

0.50/0.50
正确答案：D 你选对了
解析：   D、因为x=40E8 0000H=0100 0000 1110 1000 0...0，y=C204 0000H=1100 0010 0000 0100 0...0，所以x和y的阶码分别为100 0000 1、100 0010 0，对阶时计算过程为1000 0001 + 0111 1100 = 1111 1101。
9单选 (0.5分)
对于IEEE 754 单精度浮点数加减运算，只要对阶时得到的两个阶之差的绝对值|ΔE| 大于等于（），就无需继续进行后续处理，此时，运算结果直接取阶大的那个数。    

得分/总分

A.
127


B.
23


C.
25


D.
128

0.00/0.50
正确答案：C 你错选为D
解析：   C、对于IEEE 754单精度浮点格式，当出现“1.bb…b + 0.00…0 01bb…b”情况时会发生“大数吃小数”现象，小数0.00…0 01bb…b中的小数点被左移了25位。
10多选 (0.5分)
变量dx 、dy 和dz 的声明和初始化如下：

double dx = (double) x;

                       double dy = (double) y;

                       double dz = (double) z;

若 float 和 double 分别采用 IEEE 754 单精度和双精度浮点数格式， sizeof(int)=4 ，则对于任意 int 型变量 x 、 y 和 z，以下哪个关系表达式是永真的？

得分/总分

A.
dx+dy == (double) (x+y)


B.
dx*dy*dz == dz*dy*dx


C.
 (dx+dy)+dz == dx+(dy+dz)

0.25/0.50

D.
dx*dx >= 0     

0.25/0.50
正确答案：C、D 你选对了
解析：   A、非永真。因为x+y可能会溢出，而dx+dy不会溢出。B、非永真。相乘的结果可能产生舍入。C、永真。因为dx、dy和dz是由32位int型数据转换得到的，而double类型可以精确表示int类型数据，并且对阶时尾数移位位数不会超过52位，因此尾数不会舍入，因而不会发生大数吃小数的情况。但是，如果dx、dy和dz是任意double类型数据，则非永真。D、永真。double型数据用IEEE 754标准表示，尾数用原码小数表示，符号和数值部分分开运算。不管结果是否溢出都不会影响乘积的符号。
