1单选(0.5分)
以下有关重定位功能的叙述中，错误的是（    ）。

得分/总分

A.
重定位的最后一步是将引用处的地址修改为与之关联（绑定）的定义处的首地址

0.50/0.50

B.
重定位的最终目标是重新确定各模块合并后每个引用所指向的目标地址


C.
重定位的第二步是确定每个段的起始地址，并确定段内每个定义处符号的地址


D.
重定位的第一步应先将相同的节合并，且将具有相同存取属性的节合并成段

正确答案：A你选对了
解析：  A、重定位最后一步是对引用处的地址进行重定位，重定位的方式有多种，只有绝对地址方式才是将引用处的地址修改为与之关联（绑定）的定义处的首地址，而对于其他重定位方式，
就不一定是这样，例如，对于PC相对地址方式，引用处填写的是一个相对地址。

2单选(0.5分)
以下有关重定位信息的叙述中，错误的是（   ）。

得分/总分

A.
重定位信息包含需重定位的位置、绑定的符号和重定位类型


B.
数据中的重定位信息在可重定位目标文件的.rel.data节中


C.
重定位信息是由编译器在生成汇编指令时产生的

0.50/0.50

D.
指令中的重定位信息在可重定位目标文件的.rel.text节中

正确答案：C你选对了
解析：  C、重定位信息应该是在汇编阶段生成的，只有在汇编阶段生成机器指令时才知道需要进行重定位的位置，因为这些需重定位的位置在机器指令中，例如，CALL指令中的偏移地址等。

3单选(0.5分)
假定“int buf[2]={10,50};”所定义的buf被分配在静态数据区，其首地址为0x8048930，bufp1为全局变量，被分配在buf随后的存储空间。以下关于“int *bufp1 = &buf[1];”的重定位的描述中，
错误的是（    ）。

得分/总分

A.
在可执行目标文件中，地址0x8048938开始的4个字节为34H、89H、04H、08H


B.
bufp1的地址为0x8048938，重定位前的内容为04H、00H、00H、00H


C.
在可重定位目标文件的.rel.data节中，有一个引用buf的重定位条目


D.
在相应的重定位条目中，对bufp1和buf的引用均采用绝对地址方式

0.50/0.50
正确答案：D你选对了
解析：  A、可执行文件已经进行了重定位，所以，bufp1所在的地址0x8048938处，应该是重定位后的值，显然应该是buf[1]的地址。重定位时通过初始值加上buf的值得到，即4+0x8048930=0x8048934，
小端方式下，4个字节分别为34H、89H、04H、08H。  B、因为buf有2个数组元素，每个元素占4B，因此bufp1的地址为0x8048930+8=0x8048938，重定位时与引用绑定的符号是buf，
即绑定的是&buf[0]，而真正赋给bufp1的是&buf[1]，引用的地址和绑定的地址相差4，所以重定位前的内容为十六进制数04 00 00 00。  C、因为“int *bufp1 = &buf[1];”是一个声明，
也即是对变量bufp1的数据类型的定义和初始化，因此这个需要重定位的初始化值将被存储在.date节中，因而重定位条目在.rel.data节中，并且是绑定buf的一个引用，即引用buf的一个重定位条目。  
D、在重定位条目中只有对buf的引用，没有对bufp1的引用，这里bufp1是一个定义。

4单选(0.5分)
假定“int buf[2]={10,50};”所定义的buf被分配在静态数据区，其首地址为0x8048930，bufp1为全局变量，也被分配在静态数据区。以下关于“bufp1 = &buf[1];”的重定位的描述中，错误的是（   ）。

得分/总分

A.
可用一条mov指令实现该赋值语句，该mov指令中有两处需要重定位


B.
在可重定位目标文件的.rel.text节中，有一个与buf相关的重定位条目


C.
在可重定位目标文件的.rel.data节中，有一个与bufp1相关的重定位条目

0.50/0.50

D.
在相应的重定位条目中，对bufp1和buf的引用均采用绝对地址方式

正确答案：C你选对了
解析：  A、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都需要重定位。  B、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，
所以，对buf的引用出现在机器代码中，即.text节中，因而重定位条目在.rel.text节中。  C、因为“bufp1 = &buf[1];”是一个赋值语句，而不是一个声明，因而不需要对.data节中的bufp1变量进行重定位，
也即重定位条目不在.rel.data节中。  D、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都是绝对地址方式。

5单选(0.5分)
以下是有关在Linux系统中启动可执行目标文件执行的叙述，其中错误的是（    ）。

得分/总分

A.
不管是哪种启动执行方式，最终都是通过调用execve()系统调用函数实现的


B.
可在CUI（命令行用户界面）中双击可执行目标文件对应的图标来启动其执行

0.50/0.50

C.
可在CUI（命令行用户界面）中的命令行提示符后输入对应的命令来启动其执行


D.
可以通过在一个程序中调用execve()系统调用函数来启动可执行文件执行

正确答案：B你选对了

6单选(0.5分)
以下是有关在Linux系统中加载可执行目标文件的叙述，其中错误的是（   ）。

得分/总分

A.
在可执行目标文件的加载过程中，其中的指令和数据被读入主存

0.50/0.50

B.
加载器通过可执行目标文件中的程序头表对可装入段进行加载


C.
任何可执行目标文件中的可装入段被映射到一个统一的虚拟地址空间


D.
可执行目标文件的加载通过execve()函数调用的加载器来完成

正确答案：A你选对了

7单选(0.5分)
以下是在Linux系统中启动并加载可执行目标文件过程中shell命令行解释程序所做的部分操作：

① 构造构造argv和envp

② 调用fork()系统调用函数

③ 调用execve()系统调用函数

④ 读入命令（可执行文件名）及参数

 启动并加载可执行目标文件的正确步骤是（    ）。

得分/总分

A.
②→④→①→③


B.
④→①→③→②


C.
④→①→②→③

0.50/0.50

D.
①→②→③→④

正确答案：C你选对了

8单选(0.5分)
以下是有关动态链接及其所链接的共享库以及动态链接生成的可执行目标文件的叙述，其中错误的是（   ）。

得分/总分

A.
生成的可执行目标文件是部分链接的，也即，其中还有部分引用没有进行重定位


B.
可执行目标文件在加载或执行时，系统将会调出动态链接器利用共享库对其进行动态链接


C.
可执行目标文件由动态链接器对可重定位目标文件和共享库中部分信息进行链接而成

0.50/0.50

D.
共享库在Linux下称为动态共享对象（.so），在Windows下称为动态链接库（.dll）

正确答案：C你选对了

9单选(0.5分)
以下是有关静态链接和动态链接比较的叙述，其中错误的是（    ）。

得分/总分

A.
静态链接情况下静态库函数在加载时被链接，动态链接情况下共享库函数可在加载或运行时被链接

0.50/0.50

B.
静态库函数代码包含在可执行目标文件中，而共享库函数代码不包含在可执行目标文件中


C.
静态库函数代码包含在进程代码段中，而共享库函数代码不包含在进程代码段中


D.
静态库函数更新后需对程序重新编译和链接，而共享库函数更新后程序无需重新编译和链接

正确答案：A你选对了

10单选(0.5分)
一个共享库文件（.so文件）由多个模块（.o文件）生成。在生成共享库文件的过程中，需要对.o文件进行处理，以生成位置无关代码。以下有关位置无关代码（PIC）生成的叙述中，错误的是（   ）。

得分/总分

A.
模块外数据的引用需要动态链接器进行重定位，重定位时在GOT中填入外部数据的地址


B.
模块内函数之间的调用可用PC相对地址实现，无需动态链接器进行重定位


C.
模块间函数调用需要动态链接器进行重定位，重定位时在GOT和PLT中填入相应内容

0.50/0.50

D.
模块内数据的引用无需动态链接器进行重定位，因为引用与定义间相对位置固定

正确答案：C你选对了



